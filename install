#!/usr/bin/env perl

#perl '-V:install.*' for dirs
#
#./build
#./build installconf
#sudo ./build install

use 5.18.0;

our $script_dir;
our $libmain_dir;
our $libfish_dir;

BEGIN {
    use File::Basename;
    $script_dir = dirname $0;
    $libmain_dir = $script_dir . '/libmain';
    $libfish_dir = $script_dir . '/libextra/fish-lib-perl';
    push @INC, $_ for $libmain_dir, $libfish_dir;
    $0 = basename $0;
}

use Fish::Opt 'opt';
use Fish::Utility;
use Fish::Utility_l qw, chd list shiftr scalarr ,;
Fish::Utility->verbose_cmds(1);

sub natatime($+);

my $USAGE = "Usage: $0 [-c for make clean]";

my $opt = opt {
    h   => 'f',
    c   => 'f',
} or error $USAGE;

info($USAGE), exit if $opt->h;

error $USAGE if @ARGV;

chd $script_dir;

my $home = $ENV{HOME} or error "Need to set env variable HOME";
my $install_dir = $home . '/.local/share/fish-vol';
my $pwd = sys_chomp 'pwd';
my $clean = $opt->c // 0;

my @cmds = (
    [
        shell => qq, mkdir -p "$install_dir" ,,
        shell => qq, cp conf "$install_dir/conf" ,,
    ],
    [
        perl => qq, chd 'libmain/fish-lib-asound' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'make',
        perl => qq, chd "$pwd" , ,
    ],
    [
        perl => qq, chd 'libmain/fish-lib-util/fish-util' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'make',
        perl => qq, chd "$pwd" , ,
    ],
    [
        perl => qq, chd 'libmain/fish_vol_xs' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'perl Makefile.PL',
        shell => 'make',
        perl => qq, chd "$pwd" ,,
    ],
);

for my $block (@cmds) {
    my $n = natatime 2, @$block;
    while (my @v = $n->()) {
        my ($executor, $what) = @v;
        $what = $what->() if ref $what eq 'CODE';
        if ($executor eq 'perl') {
            do_perl($what);
        }
        elsif ($executor eq 'shell') {
            do_shell($what);
        }
        else {
            ierror "Invalid:", BR $executor;
        }
    }
}

exit;

sub do_perl {
    my ($p) = @_;
    # perl
    return unless strip_s $p;
    info $p;
    eval "$p; 1" or error d8 "Error: $@";
}

sub do_shell {
    my ($c) = @_;
    return unless strip_s $c;
    sys_system $c;
}

# assume well-behaved args.
sub natatime($+) {
    my ($n, $ary) = @_;
    my $i = -1;
    my $length = @$ary;
    sub {
        my @ret;
        for my $j (1 .. $n) {
            $i++;
            if ($i == $length - 1) {
                iwar 'j', $j, 'n', $n unless $j == $n;  #premature end
            }
            if ($i == $length) {
                return; #done
            }
            push @ret, $ary->[$i];
        }

        @ret
    }
}
