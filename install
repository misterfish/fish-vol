#!/usr/bin/env perl

#perl '-V:install.*' for dirs
#
# ./build
# ./build installconf [-d=~/.local/share/fish-vol]
# optional: sudo ./build install [-d=...]

use 5.18.0;

our $script_dir;
our $libmain_dir;
our $libfish_dir;

BEGIN {
    use File::Basename;
    $script_dir = dirname $0;
    $libmain_dir = $script_dir . '/libmain';
    $libfish_dir = $script_dir . '/libextra/fish-lib-perl';
    push @INC, $_ for $libmain_dir, $libfish_dir;
    $0 = basename $0;
}

use Fish::Opt 'opt';
use Fish::Utility;
use Fish::Utility_l qw, chd list shiftr scalarr ,;
Fish::Utility->verbose_cmds(1);
use Fish::Class 'o';

# like natatime from List::MoreUtils
sub chunk;
sub get_default_dir;

my $USAGE = "Usage: $0 [-c for make clean]";

my $opt = opt {
    h   => 'f',
    c   => 'f',
    d   => 's',
} or error $USAGE;

info($USAGE), exit if $opt->h;

my $g = o(
    mode => shift // '',
    dir => $opt->d // '',
);

error $USAGE if @ARGV;

chd $script_dir;

my $home = $ENV{HOME} or error "Need to set env variable HOME";

# XX
my $install_dir = $home . '/.local/share/fish-vol';

my $pwd = sys_chomp 'pwd';
my $clean = $opt->c // 0;

# - - -

my @cmds = (
    [
        shell => qq, mkdir -p "$install_dir" ,,
        shell => qq, cp conf "$install_dir/conf" ,,
    ],
    [
        perl => qq, chd 'libmain/fish-lib-asound' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'make',
        perl => qq, chd "$pwd" , ,
    ],
    [
        perl => qq, chd 'libmain/fish-lib-util/fish-util' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'make',
        perl => qq, chd "$pwd" , ,
    ],
    [
        perl => qq, chd 'libmain/fish_vol_xs' , ,
        shell => sub { $clean ? 'make clean' : '' },
        shell => 'perl Makefile.PL',
        shell => 'make',
        perl => qq, chd "$pwd" ,,
    ],
);

# - - - -

go(\@cmds);

exit;

sub go {
    my ($cmds) = @_;
    for my $block (list $cmds) {
        my $n = chunk 2, $block;
        while (my @v = $n->()) {
            my ($executor, $what) = @v;
            $what = $what->() if ref $what eq 'CODE';
            $executor eq 'perl' ?
                do_perl($what) :
            $executor eq 'shell' ?
                do_shell($what) :
            ierror "Invalid:", BR $executor;
        }
    }
}

sub do_perl {
    my ($p) = @_;
    # perl
    return unless strip_s $p;
    info $p;
    eval "$p; 1" or error d8 "Error: $@";
}

sub do_shell {
    my ($c) = @_;
    return unless strip_s $c;
    sys_system $c;
}

# assume well-behaved args.
sub chunk {
    my ($n, $ary) = @_;
    my $i = -1;
    my $length = @$ary;
    sub {
        my @ret;
        for my $j (1 .. $n) {
            $i++;
            if ($i == $length - 1) {
                iwar 'j', $j, 'n', $n unless $j == $n;  #premature end
            }
            if ($i == $length) {
                return; #done
            }
            push @ret, $ary->[$i];
        }

        @ret
    }
}
